<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Anatomy Viewer</title>
<style>
  html,body{margin:0;height:100%;background:#58606A;color:#0C0F13;font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  #canvas{width:100%;height:100%;display:block}
  #hud{position:fixed;top:10px;right:10px;z-index:12}
  .btn{display:inline-flex;gap:8px;background:#14181f;color:#e6e6e6;border:1px solid #2a3140;border-radius:8px;padding:8px 10px;font-size:14px;cursor:pointer}
  .btn:active{transform:translateY(1px)}
  .btn .icon{width:16px;height:16px;filter:invert(1);opacity:.9}
  #dots{position:fixed;inset:0;pointer-events:none;z-index:11}
  .dot{position:absolute;transform:translate(-50%,-50%);pointer-events:auto;cursor:pointer;width:6px;height:6px;border-radius:50%;background:#fff;border:2px solid #000}
  .dot.dim{opacity:.45}
  .dot.hidden{display:none}</style>
<script async src="https://unpkg.com/es-module-shims@1.10.0/dist/es-module-shims.js"></script>
<script type="importmap">{"imports":{
  "three":"https://unpkg.com/three@0.161.0/build/three.module.js",
  "three/addons/":"https://unpkg.com/three@0.161.0/examples/jsm/"
}}</script>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="dots"></div>
  <div id="hud">
    <button id="reset" class="btn" title="Reset camera and selection">
      <img class="icon" src="https://raw.githubusercontent.com/ken-odonnell/model-host/main/reset-icon.svg" alt=""> Reset
    </button>
  </div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';

// Config
const GLB_URLS = ['https://github.com/ken-odonnell/model-host/blob/main/Avatar.glb'];
const EMISSIVE_FALLBACK = 'https://github.com/ken-odonnell/model-host/blob/main/AvatarTexture.png';
const HOVER_EMI = 6, EMISSIVE_I = 2, ALBEDO = '#2b2b2b', EMI_COLOR = '#9EDFFF', ANIM_MS = 1000;
const BLOCK = new Set(['body']);
const setStatus = ()=>{};

// Soft-constraint params
const PAN_SOFT_RADIUS = 0.60;   // as fraction of model radius
const PAN_PULL = 0.18;          // 0..1, easing per frame when out of bounds
const PITCH_MIN = THREE.MathUtils.degToRad(40);  // too-high looking down -> push toward 25°
const PITCH_MAX = THREE.MathUtils.degToRad(140); // too-low looking up   -> push toward 155°
const PITCH_PULL = 0.12;        // easing toward allowed pitch

// Zoom + idle spin
const ZOOM_MIN_MULT = 0.15;     // min zoom-in distance as multiple of model radius
const ZOOM_MAX_MULT = 6;        // max zoom-out distance as multiple of model radius
const HOME_SPIN_SPEED = 0.05;   // rad/s for idle home rotation


// Renderer/scene
const renderer = new THREE.WebGLRenderer({ canvas:document.getElementById('canvas'), antialias:true, alpha:true });
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.setSize(innerWidth, innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.NoToneMapping;
renderer.setClearColor(0x000000,0);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.01, 10000);
const controls = new OrbitControls(camera, renderer.domElement);
Object.assign(controls,{enableDamping:true,dampingFactor:.06,zoomSpeed:1.6,rotateSpeed:1.2,panSpeed:1.2,minDistance:.02,maxDistance:2000,zoomToCursor:true});
scene.add(new THREE.HemisphereLight(0xffffff,0x404040,.5));

// State
let root=null, meshes=[], parts=new Map(), centers=new Map(), anchors=new Map(), dots=new Map();
let lit=new Set(), anim=new WeakMap(), orig=new WeakMap(), hoveredCanon=null;
let homePos=new THREE.Vector3(), homeTgt=new THREE.Vector3(), homeFov=50, radius=1;
let lastClick={ckey:null,anchor:null};
let softHoldUntil = 0; // pause soft constraints during focus tweens
let panCenter = null; // soft pan center (focus anchor)
let idleResumeAt = 0; // resume idle spin after this timestamp
const turntable={on:false,center:new THREE.Vector3(),speed:.15,token:0};
const stopTurn=()=>{turntable.on=false;turntable.token++;};
function spinIfIdle(){ if(lit.size===0){ turntable.speed = HOME_SPIN_SPEED; startTurn(0, homeTgt.clone(), 1); } }
const startTurn=(ms,center,sign=1)=>{const tok=++turntable.token;setTimeout(()=>{if(turntable.token!==tok)return;turntable.on=true;turntable.center.copy(center);turntable.speed=Math.abs(turntable.speed)*(sign>=0?1:-1);},ms);};
// Idle recenter helpers
function nearHome(){
  return controls.target.distanceTo(homeTgt) < radius*0.02 &&
         camera.position.distanceTo(homePos) < radius*0.05;
}
function recenterForIdle(){
  const dur=900; softHoldUntil = performance.now()+dur+120; camTween(homePos, homeTgt, dur, homeFov);
}

// Utils
const V3 = (...a)=>new THREE.Vector3(...a);
const canon = s => String(s||'').replace(/([a-z])([A-Z])/g,'$1 $2').replace(/[_-]+/g,' ').replace(/\b(null|left|right|l|r)\b/gi,'').replace(/ +/g,' ').trim().toLowerCase();
const topPart = o => { let c=o, n=o.name||''; while(c&&c.parent&&c.parent!==root){ if(c.parent.name) n=c.parent.name; c=c.parent; } return n||o.parent?.name||o.name||''; };
const title = s => (s||'').split(' ').map(w=>w?w[0].toUpperCase()+w.slice(1):'').join(' ');
const sideToken = s => { const x=String(s||'').toLowerCase();
  // detect side tokens 'l'/'r' even when wrapped with underscores like _L_ or _R_
  if (/(^|[^a-z0-9])l([^a-z0-9]|$)/i.test(x) || /left/.test(x)) return 'l';
  if (/(^|[^a-z0-9])r([^a-z0-9]|$)/i.test(x) || /right/.test(x)) return 'r';
  return null;
};
const ghRaw = u => { try{const url=new URL(u,location.href); if(url.hostname==='github.com'){const [user,repo,mode,branch,...rest]=url.pathname.split('/').filter(Boolean); if(['blob','raw','edit','tree'].includes(mode)) return `https://raw.githubusercontent.com/${user}/${repo}/${branch}/${rest.join('/')}`;} }catch{} return u; };
const urlDir = u => { try{const url=new URL(u); url.pathname=url.pathname.replace(/[^/]*$/,''); return url.href;}catch{return u;} };

// Turntable rules (left = same as Armpit_L, right = mirrored)
const ROTATE_WITH_ARMPIT = new Set(['armpit','lower arm','upper arm','inner thigh','outer thigh','flank','flanks','banana roll','bananaroll']);
const sideSign = (ref, xFallback)=>{ const s = sideToken(ref); if (s) return s==='l' ? 1 : -1; return (xFallback >= homeTgt.x) ? -1 : 1; };
const shouldMirrorTurn = ckey => ROTATE_WITH_ARMPIT.has(ckey);
// Parts that should spin slowly on focus (center-line areas)
const SPIN_ON_FOCUS = new Set(['abdomen','abs','chest','upper back','upperback','mid back','midback','lower back','lowerback','pubic','neck chin','neck/chin','neckchin']);

// Materials + shading
const cloneStd = m => {
  const make = x=>{
    const out=new THREE.MeshStandardMaterial();
    out.map=x?.map||null; out.normalMap=x?.normalMap||null; out.roughnessMap=x?.roughnessMap||null; out.metalnessMap=x?.metalnessMap||null; out.emissiveMap=x?.emissiveMap||null;
    out.color = new THREE.Color(ALBEDO);
    out.emissive = out.emissiveMap ? new THREE.Color(EMI_COLOR) : new THREE.Color(0x000000);
    out.emissiveIntensity = EMISSIVE_I;
    out.roughness = typeof x?.roughness==='number'?x.roughness:1;
    out.metalness = typeof x?.metalness==='number'?x.metalness:0;
    out.transparent=!!x?.transparent; out.opacity = typeof x?.opacity==='number'?x.opacity:1;
    return out;
  };
  return Array.isArray(m)?m.map(make):make(m||{});
};
const storeOrig = mesh=>{ const m=mesh.material; orig.set(mesh,{emi:m.emissive?.clone(), emiI:('emissiveIntensity'in m)?m.emissiveIntensity:1}); anim.set(mesh,{t:1,target:1}); };
const wantLit = m => lit.size===0 || (!BLOCK.has(topPart(m).toLowerCase()) && lit.has(topPart(m)));
const isHovered = m => hoveredCanon && canon(topPart(m))===hoveredCanon;
const shade = m=>{
  const a=anim.get(m)||{t:1}, k=a.t, e=k*k*(3-2*k);
  const emissBase = m.material.emissiveMap ? new THREE.Color(EMI_COLOR) : (orig.get(m)?.emi || new THREE.Color(0x000000));
  const emiMul = (orig.get(m)?.emiI||1) * (isHovered(m)? HOVER_EMI : EMISSIVE_I) * (0.25 + (1-0.25)*e);
  if(m.material.emissive) m.material.emissive.copy(emissBase).multiplyScalar(0.2+(1-0.2)*e);
  if('emissiveIntensity'in m.material) m.material.emissiveIntensity = emiMul;
};
const updateTargets=()=>meshes.forEach(m=>{const a=anim.get(m)||{t:1}; a.target = wantLit(m)?1:0; anim.set(m,a);});

// Camera frame + tween
let tween=null, queue=[];
const camTween=(toPos,toTgt,dur=800,fovTo=null)=>{
  const t={t0:performance.now(),dur,fromP:camera.position.clone(),fromT:controls.target.clone(),toP:toPos.clone(),toT:toTgt.clone(),fFrom:camera.fov,fTo:fovTo};
  if(tween) queue.push(t); else tween=t;
};
const stepTween=()=>{
  if(!tween) return;
  const k=Math.min(1,(performance.now()-tween.t0)/tween.dur), e=k*k*(3-2*k);
  camera.position.lerpVectors(tween.fromP,tween.toP,e);
  controls.target.lerpVectors(tween.fromT,tween.toT,e);
  if(tween.fTo!=null){ camera.fov=THREE.MathUtils.lerp(tween.fFrom,tween.fTo,e); camera.updateProjectionMatrix(); }
  if(k>=1){ tween=null; if(queue.length){ tween=queue.shift(); tween.t0=performance.now(); } }
};
const frameRoot=()=>{
  const box=new THREE.Box3().setFromObject(root), s=box.getBoundingSphere(new THREE.Sphere());
  root.position.y -= box.min.y;
  radius=Math.max(1e-3,s.radius);
  const dist=radius*2.2;
  camera.position.set(s.center.x, s.center.y+radius*.5, s.center.z+dist);
  controls.target.copy(s.center);
  homePos.copy(camera.position); homeTgt.copy(controls.target); homeFov=camera.fov;
  camera.near=Math.max(.01,radius*.01); camera.far=Math.max(1000,radius*50); camera.updateProjectionMatrix();
  controls.minDistance=radius*ZOOM_MIN_MULT; controls.maxDistance=radius*ZOOM_MAX_MULT;
};
const home=()=>{ queue.length=0; tween=null; camTween(homePos,homeTgt,600,homeFov); spinIfIdle(); };

// Parts, centers, anchors, dots
const groupsByCanon = ()=>{ const map=new Map(); for(const name of parts.keys()){ if(BLOCK.has(name.toLowerCase())) continue; const k=canon(name); if(!map.has(k)) map.set(k,[]); map.get(k).push(name);} return map; };
const computeCenters=()=>{ centers.clear(); for(const [name,rec] of parts){ if(BLOCK.has(name.toLowerCase())) continue; const box=new THREE.Box3(); rec.meshes.forEach(m=>box.expandByObject(m)); centers.set(name, box.getCenter(new THREE.Vector3())); } };
const dotsLayer=document.getElementById('dots');
const clearDots=()=>{ dotsLayer.innerHTML=''; dots.clear(); anchors.clear(); };
const authoredNulls=()=>{ const out=[]; root.traverse(o=>{ if(!o.isMesh && /_null\b/i.test(o.name||'')) out.push(o); }); return out; };
const makeDot=(anchorKey,canonKey)=>{ const el=document.createElement('div'); el.className='dot'; el.title=canonKey; el.dataset.anchor=anchorKey; el.dataset.canon=canonKey; el.addEventListener('click',e=>{ e.stopPropagation(); toggleByCanon(canonKey, anchorKey); }); dotsLayer.appendChild(el); dots.set(anchorKey,el); };
const buildDots=()=>{
  clearDots();
  const seen=new Set();
  for(const o of authoredNulls()){
    const w=o.getWorldPosition(new THREE.Vector3()), local=w.clone(); root.worldToLocal(local);
    const c=canon(o.name); if(BLOCK.has(c)) continue;
    anchors.set(o.name, local); makeDot(o.name, c); seen.add(c);
  }
  const groups=groupsByCanon();
  for(const [key,members] of groups){
    if(seen.has(key)) continue;
    const hasSides = members.some(n=>/_([lr])\b/i.test(n) || /\b(left|right)\b/i.test(n));
    if(hasSides){ members.forEach(n=>{ anchors.set(n, (centers.get(n)||new THREE.Vector3()).clone()); makeDot(n,key); }); }
    else{ const c=new THREE.Vector3(); members.forEach(n=>c.add(centers.get(n)||new THREE.Vector3())); c.multiplyScalar(1/Math.max(1,members.length)); anchors.set(key,c); makeDot(key,key); }
  }
};
const updateDots=()=>{
  if(!root) return;
  const proj=new THREE.Vector3(), camP=camera.position.clone(), r=renderer.domElement.getBoundingClientRect(), ray=new THREE.Raycaster();
  for(const [aKey,el] of dots){
    const local=anchors.get(aKey); if(!local) continue;
    const w=local.clone(); root.localToWorld(w);
    proj.copy(w).project(camera);
    el.style.left = ((proj.x*.5+.5)*r.width+r.left)+'px';
    el.style.top  = ((-proj.y*.5+.5)*r.height+r.top)+'px';
    const dir=new THREE.Vector3().subVectors(w,camP), dist=dir.length(); dir.normalize(); ray.set(camP,dir);
    const hit=ray.intersectObjects(meshes,true); const blocked=hit.length && hit[0].distance<dist-.005; el.classList.toggle('hidden',blocked);
    const k=el.dataset.canon, mem=Array.from(parts.keys()).filter(n=>canon(n)===k), sel=mem.some(n=>lit.has(n));
    el.classList.toggle('dim', lit.size>0 && !sel);
    el.style.opacity = (hoveredCanon && k===hoveredCanon) ? '1' : '';
  }
};

// Selection + focus
const focusTo = (center, partR, opts={})=>{
  const pad=2.4, fov=THREE.MathUtils.degToRad(camera.fov);
  const distFit=(partR/Math.tan(fov*.5))*pad;
  const toFov = THREE.MathUtils.clamp(homeFov-10,28,45);
  const dur = 900; // keep in sync with camTween duration
  softHoldUntil = performance.now() + dur + 120; // suppress soft-constraint bump during/after tween
  panCenter = center.clone();
  if(opts.fromSide){
    const s = Math.sign(opts.fromSide)||1, a=Math.SQRT1_2;
    const toPos=V3(center.x + s*distFit*a, center.y + partR*.08, center.z + distFit*a);
    camTween(toPos, center.clone(), dur, toFov);
  } else {
    const dir=new THREE.Vector3().subVectors(camera.position,controls.target).normalize();
    const toPos=center.clone().addScaledVector(dir, Math.max(distFit, controls.minDistance*1.5));
    camTween(toPos, center.clone(), dur, toFov);
  }
};
const getAnchorFor = (canonKey, focusMember)=>{
  if(focusMember){
    if(anchors.has(focusMember)) return focusMember;
    if(anchors.has(`${focusMember}_Null`)) return `${focusMember}_Null`;
    const s=sideToken(focusMember);
    if(s){ for(const k of anchors.keys()){ if(canon(k)===canonKey){ const L=/(?:_l\b|left)/i.test(k), R=/(?:_r\b|right)/i.test(k); if((s==='l'&&L)||(s==='r'&&R)) return k; } } }
  }
  for(const k of anchors.keys()) if(canon(k)===canonKey) return k;
  return null;
};
const toggleByCanon = (ckey, focusMember=null)=>{
  // Determine anchor first so we can distinguish L vs R for double-click reset
  const ak = getAnchorFor(ckey, focusMember);
  const repAnchor = ak || focusMember || null;

  const groups = groupsByCanon(), members = groups.get(ckey) || [];
  const wasSelected = members.some(n=>lit.has(n));

  const repeated = (lastClick.ckey===ckey && lastClick.anchor===repAnchor && wasSelected);
  lastClick = { ckey: ckey, anchor: repAnchor };

  // toggle selection
  members.forEach(n=> wasSelected ? lit.delete(n) : lit.add(n));
  updateTargets();
  if(repeated){ stopTurn(); panCenter=null; home(); return; }

  const bboxOfMembers = list=>{ const box=new THREE.Box3(); list.forEach(n=>{ const rec=parts.get(n); if(rec) rec.meshes.forEach(m=>box.expandByObject(m)); }); const s=box.getBoundingSphere(new THREE.Sphere()); return {c:s.center, r:Math.max(1e-3,s.radius)}; };

  if (ak && anchors.has(ak)){
    const local=anchors.get(ak).clone();
    const world=local.clone(); root.localToWorld(world);
    const sign = sideSign(focusMember||ak, world.x);

    if (ckey==='armpit'){
      focusTo(world, Math.max(1e-3, radius*.18), {fromSide:sign});
      startTurn(900, world, -sign);
    } else {
      const partR = Math.max(1e-3, radius*.18);
      if (ckey==='upper arm' || ckey==='lower arm') {
        focusTo(world, partR, {fromSide:sign});
        startTurn(900, world, -sign);
      } else if (SPIN_ON_FOCUS.has(ckey)) {
        focusTo(world, partR);
        turntable.speed = HOME_SPIN_SPEED;
        startTurn(900, world, 1);
      } else {
        focusTo(world, partR);
        if (shouldMirrorTurn(ckey)) startTurn(900, world, -sign); else stopTurn();
      }
    }
    return;
  }

  const targetList = focusMember && parts.has(focusMember) ? [focusMember] : members;
  if(targetList.length){
    const {c,r}=bboxOfMembers(targetList);
    const sign = sideSign(focusMember, c.x);
    if(ckey==='armpit'){
      focusTo(c, r, {fromSide:sign}); startTurn(900, c.clone(), -sign);
    } else {
      if (ckey==='upper arm' || ckey==='lower arm') {
        focusTo(c, r, {fromSide:sign});
        startTurn(900, c.clone(), -sign);
      } else if (SPIN_ON_FOCUS.has(ckey)) {
        focusTo(c, r);
        turntable.speed = HOME_SPIN_SPEED;
        startTurn(900, c.clone(), 1);
      } else {
        focusTo(c, r);
        if(shouldMirrorTurn(ckey)) startTurn(900, c.clone(), -sign); else stopTurn();
      }
    }
  }
};

// Loader + attach
const makeLoader=()=>{ const mgr=new THREE.LoadingManager(); const ktx2=new KTX2Loader(mgr).setTranscoderPath('https://unpkg.com/three@0.161.0/examples/jsm/libs/basis/').detectSupport(renderer); const ld=new GLTFLoader(mgr); ld.setCrossOrigin('anonymous'); ld.setKTX2Loader(ktx2); return {ld,mgr}; };
const loadGLB=async url=>{
  const base=urlDir(ghRaw(url)); setStatus('Loading '+url.split('/').pop()+' …');
  try{ const {ld,mgr}=makeLoader(); mgr.setURLModifier(u=>ghRaw(u)); ld.setResourcePath(base); const g=await ld.loadAsync(ghRaw(url)); setStatus('Loaded'); return g; }
  catch{
    const tryMap=[EMISSIVE_FALLBACK,'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMB/6XK5NQAAAAASUVORK5CYII='];
    for(const tex of tryMap){ try{ const {ld,mgr}=makeLoader(); mgr.setURLModifier(u=>/\.(png|jpe?g|webp|ktx2)$/i.test(ghRaw(u))? ghRaw(tex) : ghRaw(u)); ld.setResourcePath(base); const g=await ld.loadAsync(ghRaw(url)); setStatus(tex===EMISSIVE_FALLBACK?'Loaded with repo texture':'Loaded with placeholder textures'); return g; }catch{} }
    throw new Error('All retries failed');
  }
};
const tryURLs=async urls=>{ for(const u of urls){ try{ return await loadGLB(u); }catch(e){ console.warn('Failed',u,e);} } return null; };
const attach= gltf=>{
  if(root){ scene.remove(root); root=null; meshes.length=0; lit.clear(); parts.clear(); clearDots(); }
  root=gltf.scene||gltf.scenes?.[0]; scene.add(root);
  root.traverse(o=>{ if(o.isMesh){ o.material=cloneStd(o.material); storeOrig(o); meshes.push(o); } });
  root.traverse(o=>{ if(o.isMesh){ let p=o; while(p.parent&&p.parent!==root) p=p.parent; const key=p.name||o.name||'Part'; if(!parts.has(key)) parts.set(key,{meshes:[]}); parts.get(key).meshes.push(o); } });
  computeCenters(); buildDots(); frameRoot(); updateTargets(); spinIfIdle();
};

// Picking + hover
const ray=new THREE.Raycaster(), ndc=new THREE.Vector2();
const pick=(cx,cy)=>{ const r=renderer.domElement.getBoundingClientRect(); ndc.x=((cx-r.left)/r.width)*2-1; ndc.y=-((cy-r.top)/r.height)*2+1; ray.setFromCamera(ndc,camera); const hits=ray.intersectObjects(meshes,true); if(!hits.length) return null; const part=topPart(hits[0].object); return BLOCK.has(part.toLowerCase())? null : part; };
const down={x:0,y:0,t:0,moved:false};
renderer.domElement.addEventListener('pointerdown',e=>{down.x=e.clientX;down.y=e.clientY;down.t=performance.now();down.moved=false; stopTurn(); idleResumeAt = performance.now()+5000;},{passive:true});
renderer.domElement.addEventListener('pointermove',e=>{ if(down.t){ if(Math.hypot(e.clientX-down.x,e.clientY-down.y)>6) down.moved=true; } const mem=pick(e.clientX,e.clientY); const k=mem?canon(mem):null; if(k!==hoveredCanon){ hoveredCanon=k; updateDots(); } },{passive:true});
renderer.domElement.addEventListener('pointerleave',()=>{ if(hoveredCanon){ hoveredCanon=null; updateDots(); } });
renderer.domElement.addEventListener('pointerup',e=>{ const dt=performance.now()-down.t, drag=down.moved||dt>300; down.t=0; idleResumeAt = performance.now()+5000; if(drag) return; const mem=pick(e.clientX,e.clientY); if(!mem) return; toggleByCanon(canon(mem), mem); },{passive:false});

// Reset
document.getElementById('reset').addEventListener('click',()=>{ updateTargets(); stopTurn(); panCenter=null; home(); });

// Soft constraints
function applySoftConstraints(dt){
  if (performance.now() < softHoldUntil) return; // avoid post-focus bump
  if (turntable.on) return; // hold constraints during turntable
  // 1) Pan-soft-limit: ease target + camera back toward home center when far
  const center = panCenter || homeTgt; // focus center or avatar center
  const delta = new THREE.Vector3().subVectors(controls.target, center);
  const lim = radius * PAN_SOFT_RADIUS;
  const d = delta.length();
  if (!down.t && d > lim){
    const k = PAN_PULL * (down.t ? 0.5 : 1.0); // weaker while dragging
    const pull = Math.min(d - lim, radius) * k;
    if (pull > 0){
      const move = delta.normalize().multiplyScalar(pull);
      controls.target.sub(move);
      camera.position.sub(move);
    }
  }
  // 2) Pitch-soft-limit: ease camera elevation toward allowed band
  const off = new THREE.Vector3().subVectors(camera.position, controls.target);
  const R = off.length(); if (R > 1e-5){
    const theta = Math.acos(THREE.MathUtils.clamp(off.y / R, -1, 1));
    let tGoal = theta;
    if (theta < PITCH_MIN) tGoal = THREE.MathUtils.lerp(theta, PITCH_MIN, PITCH_PULL * (down.t ? 0.5 : 1.0));
    else if (theta > PITCH_MAX) tGoal = THREE.MathUtils.lerp(theta, PITCH_MAX, PITCH_PULL * (down.t ? 0.5 : 1.0));
    if (tGoal !== theta){
      const phi = Math.atan2(off.x, off.z);
      const sinT = Math.sin(tGoal), cosT = Math.cos(tGoal);
      const sinP = Math.sin(phi),  cosP = Math.cos(phi);
      const v = new THREE.Vector3(sinT*sinP, cosT, sinT*cosP).multiplyScalar(R);
      camera.position.copy(controls.target).add(v);
    }
  }
}

// Resize
addEventListener('resize',()=>{ renderer.setSize(innerWidth,innerHeight); camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); updateDots(); });

// Animate
let last=performance.now();
const animate=()=>{
  const now=performance.now(), dt=now-last; last=now;
  meshes.forEach(m=>{ const a=anim.get(m)||{t:1,target:1}; const d=a.target-a.t; if(d){ a.t += Math.sign(d)*Math.min(Math.abs(d), Math.min(1,dt/ANIM_MS)); anim.set(m,a); } shade(m); });
  if(turntable.on && !tween){
    const v=new THREE.Vector3().subVectors(camera.position,turntable.center);
    const ang=turntable.speed*(dt/1000), c=Math.cos(ang), s=Math.sin(ang);
    const nx=v.x*c - v.z*s, nz=v.x*s + v.z*c; v.x=nx; v.z=nz;
    camera.position.copy(turntable.center).add(v); controls.target.copy(turntable.center);
  }
  stepTween(); applySoftConstraints(dt);
  if(!turntable.on && !tween && lit.size===0 && performance.now()>=idleResumeAt){
    if(!nearHome()) recenterForIdle(); else { turntable.speed = HOME_SPIN_SPEED; startTurn(0, homeTgt.clone(), 1); }
  }
  controls.update(); renderer.render(scene,camera); updateDots(); requestAnimationFrame(animate);
};
requestAnimationFrame(animate);

// Optional programmatic selection helpers
function selectByName(name){
  const n = String(name||'').toLowerCase();
  if (/^armpit_l(?:_null)?$/.test(n)) { toggleByCanon('armpit','Armpit_L'); return; }
  if (/^armpit_r(?:_null)?$/.test(n)) { toggleByCanon('armpit','Armpit_R'); return; }
  toggleByCanon(canon(name), name);
}
window.selectByName = selectByName;

// Boot
(async()=>{ try{ const gltf=await tryURLs(GLB_URLS); if(gltf) attach(gltf); else setStatus('All sources failed.'); }catch(e){ console.error(e); setStatus('Error: '+(e?.message||e)); } })();

// --- Tests ---
(function runTests(){
  try{
    console.log('%c[TEST] start','color:#0f0');
    console.assert(typeof THREE !== 'undefined','THREE loaded');
    console.assert(document.getElementById('canvas'),'canvas exists');
    console.assert(typeof toggleByCanon==='function','toggleByCanon exists');
    console.assert(typeof selectByName==='function','selectByName exists');
    console.assert(typeof applySoftConstraints==='function','applySoftConstraints exists');
    console.assert(!/\$1\b/.test(document.currentScript?.textContent||''),'no stray $1 placeholders');
    console.assert(typeof ZOOM_MAX_MULT==='number' && ZOOM_MAX_MULT>0,'zoom cap constant');
    console.assert(typeof ZOOM_MIN_MULT==='number' && ZOOM_MIN_MULT>0,'zoom min constant');
    console.assert(typeof SPIN_ON_FOCUS==='object' && SPIN_ON_FOCUS.has,'spin-on-focus set present');
    console.assert(typeof HOME_SPIN_SPEED==='number','idle spin speed const');
    console.assert(typeof startTurn==='function' && typeof stopTurn==='function','turntable controls exist');
    console.assert(typeof nearHome==='function' && typeof recenterForIdle==='function','idle recenter helpers exist');
    console.assert(sideToken('Armpit_L_Null')==='l','sideToken L null');
    console.assert(sideToken('Armpit_R_Null')==='r','sideToken R null');
    console.assert(sideToken('UpperArm_L_Null')==='l','sideToken UL null');
    console.assert(sideToken('UpperArm_R_Null')==='r','sideToken UR null');
    console.log('%c[TEST] end','color:#0f0');
  }catch(e){ console.warn('[TEST] error', e); }
})();
</script>
</body>
</html>
