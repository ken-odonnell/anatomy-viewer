<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Anatomy Viewer — Transparent canvas, off‑white page, improved home tween</title>
  <style>
    html,body{margin:0;height:100%;background:#575757;color:#222;font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
    #hud{position:fixed;top:10px;right:10px;display:flex;gap:10px;z-index:10;align-items:center}
    .btn{display:inline-flex;align-items:center;gap:8px;background:#222;color:#fff;border:1px solid #333;border-radius:8px;padding:8px 10px;font-size:14px;cursor:pointer}
    .btn:active{transform:translateY(1px)}
    #canvas{width:100%;height:100%;display:block}
  </style>
  <script async src="https://unpkg.com/es-module-shims@1.10.0/dist/es-module-shims.js"></script>
  <script type="importmap">
  {"imports":{
    "three":"https://unpkg.com/three@0.161.0/build/three.module.js",
    "three/addons/":"https://unpkg.com/three@0.161.0/examples/jsm/"
  }}
  </script>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="hud">
    <button id="reset" class="btn" title="Reset camera and selection">
      <svg class="icon" viewBox="0 0 24 24" width="18" height="18" aria-hidden="true" style="color:#fff"><path fill="none" stroke="currentColor" stroke-width="2" d="M20,8 C18.5974037,5.04031171 15.536972,3 12,3 C7.02943725,3 3,7.02943725 3,12 C3,16.9705627 7.02943725,21 12,21 L12,21 C16.9705627,21 21,16.9705627 21,12 M21,3 L21,9 L15,9"/></svg>
      <span>Reset</span>
    </button>
  </div>

  <!-- Optional Base64 GLB embed. Leave empty unless embedding valid Base64. -->
  <script id="embedded-glb" type="application/octet-stream"></script>

  <script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
  import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

  // ---------- Config ----------
  const GLB_URLS = [
    'https://github.com/ken-odonnell/model-host/raw/refs/heads/main/Avatar.glb',
    'https://raw.githubusercontent.com/ken-odonnell/model-host/main/Avatar.glb',
    './assets/Avatar.glb','./Avatar.glb','./assets/avatar.glb','./avatar.glb'
  ];
  const BLOCK_LIST = new Set(['body']); // non-selectable
  const LIT_COLOR = 0xffffff;
  const DIM_COLOR = 0xbfbfbf;
  const TRANSITION_MS_DIM_OUT = 500;    // 0.5s dim
  const TRANSITION_MS_LIGHT_IN = 1000;  // 1s light
  const BASE_OVERLAY_OPACITY = 0.12;    // subtle hints when nothing selected

  // ---------- DOM ----------
  const canvas = document.getElementById('canvas');
  const resetBtn = document.getElementById('reset');

  // ---------- Three.js ----------
  const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.NoToneMapping;
  renderer.setClearColor(0x000000, 0); // transparent canvas, page shows through

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.01, 10000);
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true; controls.dampingFactor = 0.06; controls.zoomSpeed = 1.6; controls.rotateSpeed = 1.2; controls.panSpeed = 1.2;
  controls.minDistance = 0.02; controls.maxDistance = 2000; controls.zoomToCursor = true;

  let root = null; let meshes = []; let litSet = new Set(); let parts = new Map();
  let bbox = new THREE.Box3(); let homeTarget = new THREE.Vector3(); let homePos = new THREE.Vector3(); let radius = 1;

  // Per-part overlay defaults: very light varied grays when no selection
  const partOverlay = new Map(); // partName -> { color: THREE.Color, opacity: number }

  function base64ToArrayBufferSafe(b64){ if(!b64) return null; const s=b64.replace(/\s+/g,''); if(!/^[A-Za-z0-9+/=]+$/.test(s) || s.length%4!==0) return null; try{ const bin=atob(s); const out=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) out[i]=bin.charCodeAt(i); return out.buffer; }catch{ return null; } }
  function isBodyName(n){ return String(n||'').trim().toLowerCase()==='body'; }
  function toUnlit(mat){ const make=(m)=>{ const x=new THREE.MeshBasicMaterial({map:m?.map??null,color:0xffffff,transparent:!!m?.transparent,opacity:typeof m?.opacity==='number'?m.opacity:1}); if(x.map){ x.map.colorSpace=THREE.SRGBColorSpace; x.map.needsUpdate=true; } return x; }; return Array.isArray(mat)?mat.map(make):make(mat||{}); }
  function setMatColor(obj,c){ if(Array.isArray(obj.material)){ for(const m of obj.material){ m.color.copy(c); m.needsUpdate=true; } } else { obj.material.color.copy(c); obj.material.needsUpdate=true; } }
  function getTopPartName(o){ let cur=o, name=o.name||''; while(cur&&cur.parent&&cur.parent!==root){ if(cur.parent.name) name=cur.parent.name; cur=cur.parent; } return name||o.parent?.name||o.name||''; }

  function collectMeshes(obj){ const list=[]; obj.traverse(n=>{ if(n.isMesh){ n.material=toUnlit(n.material); // tween + overlay per mesh
      n.userData.mix = 1;           // 1 lit, 0 dim
      n.userData.targetMix = 1; n.userData.fromMix = 1; n.userData.t0 = 0; n.userData.dur = 0;
      n.userData.cLit = new THREE.Color(LIT_COLOR); n.userData.cDim = new THREE.Color(DIM_COLOR);
      const part = getTopPartName(n);
      if(!partOverlay.has(part)){
        const g = 0.90 + Math.random()*0.08; // 0.90..0.98 subtle light gray tint
        const c = new THREE.Color(g, g, g);
        const op = isBodyName(part) ? 0.0 : BASE_OVERLAY_OPACITY; // Body no overlay
        partOverlay.set(part, { color: c, opacity: op });
      }
      const po = partOverlay.get(part);
      n.userData.overlayColor = po.color.clone();
      n.userData.overlayOpacity = po.opacity;
      list.push(n);
    } }); return list; }

  function combinedColor(m){
    const cDimLit = m.userData.cDim.clone().lerp(m.userData.cLit, m.userData.mix);
    // Keep selected normal. Unselected darker when a selection exists.
    const partName = getTopPartName(m);
    let oColor = m.userData.overlayColor;
    let oOpacity = m.userData.overlayOpacity;
    if (litSet.size > 0) {
      if (isBodyName(partName) || litSet.has(partName)) {
        oOpacity = 0.0; // fully lit
      } else {
        oOpacity = Math.min(1.0, oOpacity + 0.28); // darker than idle
        oColor = oColor.clone().multiplyScalar(0.85);
      }
    }
    const overlayMix = new THREE.Color(1,1,1).lerp(oColor, oOpacity);
    return cDimLit.multiply(overlayMix);
  }
  function updateMeshColor(m){ setMatColor(m, combinedColor(m)); }

  function startTween(m, toMix, durMs){ m.userData.fromMix = m.userData.mix; m.userData.targetMix = toMix; m.userData.t0 = performance.now(); m.userData.dur = Math.max(1, durMs|0); }
  function setTargets(){
    const any = litSet.size>0; // none selected => all lit with subtle tints
    for(const m of meshes){
      const part = getTopPartName(m);
      const isBody = isBodyName(part);
      const shouldLit = any ? (!isBody && litSet.has(part)) : true;
      const to = shouldLit ? 1 : 0;
      if (to !== m.userData.targetMix) {
        const goingDim = m.userData.mix > to;
        startTween(m, to, goingDim ? TRANSITION_MS_DIM_OUT : TRANSITION_MS_LIGHT_IN);
      }
    }
  }
  function updateTweens(){
    const now = performance.now();
    for(const m of meshes){
      const dur = m.userData.dur|0; if(!dur) { updateMeshColor(m); continue; }
      const t = Math.min(1, (now - m.userData.t0) / dur);
      const e = t*t*(3 - 2*t);
      m.userData.mix = THREE.MathUtils.lerp(m.userData.fromMix, m.userData.targetMix, e);
      updateMeshColor(m);
      if (t >= 1) { m.userData.dur = 0; m.userData.mix = m.userData.targetMix; }
    }
  }

  function groundSnapAndFrame(){
    const bbox = new THREE.Box3().setFromObject(root);
    const minY=bbox.min.y; root.position.y -= minY;
    bbox.setFromObject(root);
    const sphere=bbox.getBoundingSphere(new THREE.Sphere());
    radius=Math.max(1e-3,sphere.radius);
    const dist=radius*2.2; camera.position.set(sphere.center.x, sphere.center.y+radius*0.5, sphere.center.z+dist);
    controls.target.set(sphere.center.x, sphere.center.y, sphere.center.z);
    homeTarget.copy(controls.target); homePos.copy(camera.position);
    camera.near=Math.max(0.01,radius*0.01); camera.far=Math.max(1000,radius*50); camera.updateProjectionMatrix();
    controls.minDistance=radius*0.05; controls.maxDistance=radius*50.0;
  }

  // ---------- Camera tween system (queueable) ----------
  let focusTween = null; // {t0,dur,fromPos,fromTgt,toPos,toTgt}
  const tweenQueue = [];
  function startCamTween(toPos, toTgt, durMs=900){
    const t={ t0: performance.now(), dur: durMs, fromPos: camera.position.clone(), fromTgt: controls.target.clone(), toPos: toPos.clone(), toTgt: toTgt.clone() };
    if(focusTween) tweenQueue.push(t); else focusTween=t;
  }
  function stepFocusTween(){
    if(!focusTween) return;
    const t = (performance.now()-focusTween.t0)/focusTween.dur; const k=Math.min(1,t); const e=k*k*(3-2*k);
    camera.position.lerpVectors(focusTween.fromPos, focusTween.toPos, e);
    controls.target.lerpVectors(focusTween.fromTgt, focusTween.toTgt, e);
    if(k>=1){ focusTween=null; if(tweenQueue.length){ focusTween=tweenQueue.shift(); focusTween.t0=performance.now(); } }
  }

  function startFocusTweenTo(center, partRadius, durMs=900){
    const fov = THREE.MathUtils.degToRad(camera.fov);
    const pad = 2.6; // a bit more space than before
    const distFit = (partRadius / Math.tan(fov*0.5)) * pad;
    const dir = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
    const toPos = new THREE.Vector3().copy(center).addScaledVector(dir, Math.max(distFit, controls.minDistance*1.5));
    startCamTween(toPos, center.clone(), durMs);
  }

  function startHomeTween(durMs=900){
    // Directly ease to home. No zoom-out or orbit steps.
    tweenQueue.length = 0; // drop any pending tweens
    focusTween = null;     // cancel current tween if any
    startCamTween(homePos.clone(), homeTarget.clone(), durMs);
  }

  const gltfLoader = new GLTFLoader(); gltfLoader.setCrossOrigin('anonymous');
  const loadFromArrayBuffer = (ab)=> new Promise((res,rej)=>gltfLoader.parse(ab,'',res,rej));
  async function tryEmbedded(){ const tag=document.getElementById('embedded-glb'); const b64=tag?tag.textContent.trim():''; const ab=base64ToArrayBufferSafe(b64); if(!ab) return null; try{ return await loadFromArrayBuffer(ab);}catch{return null;} }
  async function tryURLs(urls){ for(const url of urls){ try{ return await gltfLoader.loadAsync(url);} catch(e){ console.warn('URL failed',url,e);} } return null; }

  function clearModel(){ if(!root) return; scene.remove(root); root=null; meshes=[]; litSet.clear(); parts.clear(); partOverlay.clear(); }
  function attachModel(gltf){
    clearModel(); root=gltf.scene||gltf.scenes?.[0]; scene.add(root); meshes=collectMeshes(root);
    parts.clear(); const top=root; const all=[]; root.traverse(o=>{ if(o.isMesh) all.push(o); });
    for(const m of all){ let p=m; while(p.parent&&p.parent!==top) p=p.parent; const key=p.name||m.name||'Part'; if(!parts.has(key)) parts.set(key,{meshes:[]}); parts.get(key).meshes.push(m); }
    groundSnapAndFrame(); setTargets();
  }

  // ---------- Picking with drag/hold guard ----------
  const raycaster=new THREE.Raycaster(); const ndc=new THREE.Vector2();
  const down = {x:0,y:0,t:0,moved:false};
  renderer.domElement.addEventListener('pointerdown', (e)=>{ down.x=e.clientX; down.y=e.clientY; down.t=performance.now(); down.moved=false; }, {passive:true});
  renderer.domElement.addEventListener('pointermove', (e)=>{ if(down.t){ const dx=e.clientX-down.x, dy=e.clientY-down.y; if(Math.hypot(dx,dy)>6) down.moved=true; } }, {passive:true});
  function doPickAt(clientX, clientY){
    const r=renderer.domElement.getBoundingClientRect(); ndc.x=((clientX-r.left)/r.width)*2-1; ndc.y=-((clientY-r.top)/r.height)*2+1; raycaster.setFromCamera(ndc,camera);
    const hits=raycaster.intersectObjects(meshes,true); if(!hits.length) return null; const part=getTopPartName(hits[0].object); if(BLOCK_LIST.has(part.toLowerCase())) return null; return part;
  }
  renderer.domElement.addEventListener('pointerup', (e)=>{
    const dt = performance.now()-down.t; const wasDrag = down.moved || dt>300; down.t=0;
    if(wasDrag) return; // ignore hold/drag clicks
    const part = doPickAt(e.clientX, e.clientY); if(!part) return;
    if(litSet.has(part)) litSet.delete(part); else litSet.add(part);
    setTargets();
    if(litSet.size===0) startHomeTween(900); else {
      const rec=parts.get(part); if(rec){ const box=new THREE.Box3(); for(const m of rec.meshes) box.expandByObject(m); const s=box.getBoundingSphere(new THREE.Sphere()); startFocusTweenTo(s.center, Math.max(1e-3,s.radius), 900); }
    }
  }, {passive:false});

  // ---------- Reset ----------
  function resetAll(){ litSet.clear(); setTargets(); startHomeTween(900); }
  resetBtn.addEventListener('click', resetAll);

  // ---------- Resize ----------
  window.addEventListener('resize', ()=>{ renderer.setSize(window.innerWidth,window.innerHeight); camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); });

  // ---------- Animate ----------
  function animate(){ requestAnimationFrame(animate); stepFocusTween(); updateTweens(); controls.update(); renderer.render(scene, camera); } animate();

  // ---------- Boot ----------
  (async function boot(){ try{ let gltf=await tryEmbedded(); if(!gltf) gltf=await tryURLs(GLB_URLS); if(gltf) attachModel(gltf); else { const g=new THREE.Group(); scene.add(g);} } catch(e){ console.error(e); }})();

  // ---------- Tests ----------
  (function tests(){
    console.log('%c[TEST] start','color:#0f0');
    const c=renderer.getClearColor(new THREE.Color());
    console.assert(renderer.getClearAlpha()===0,'canvas transparent');
    console.assert(BLOCK_LIST.has('body'),'Body blocked');
    console.assert(document.getElementById('reset'),'Reset exists');
    // Added tests
    console.assert(typeof startHomeTween==='function','home tween exists');
    console.assert(typeof startFocusTweenTo==='function','focus tween exists');
    // extra: ensure home tween clears queue
    tweenQueue.push({t0:0,dur:1,fromPos:camera.position.clone(),fromTgt:controls.target.clone(),toPos:camera.position.clone(),toTgt:controls.target.clone()});
    startHomeTween(1);
    console.assert(tweenQueue.length===0,'home tween clears queue');
    console.log('%c[TEST] end','color:#0f0');
  })();

  </script>
</body>
</html>
